
"Integrated projection of leaf area for a single leaf inclination of Œ∏‚Çó, assumes azimuthally uniform distribution"
function A(Œ∏::FT, Œ∏‚Çó::FT) where FT<:Real # Suniti: why not use the expressions in Eq 35-36 from Schultis & Myneni (1987)?
    a = cos(Œ∏) * cos(Œ∏‚Çó)
    #@show Œ∏
    # Eq. 14.24 in Bonan et al.
    if Œ∏‚Çó ‚â§ (FT(œÄ/2) - Œ∏)
    #@show "<"
    #@show Œ∏‚Çó, a
        return a
    else
    #@show ">"
        b = sin(Œ∏) * sin(Œ∏‚Çó)
        c = sqrt(sin(Œ∏‚Çó)^2  - cos(Œ∏)^2)
     #   @show Œ∏‚Çó, FT(2/œÄ)*(c + a * asin(a/b))
        return FT(2/œÄ)*(c + a * asin(a/b))
    end
end

"Integrated projection of leaf area for a single leaf inclination of Œ∏‚Çó, assumes azimuthally uniform distribution"
function Asm(Œ∏::FT, Œ∏‚Çó::FT) where FT<:Real # Suniti: Eq 35-36 from Schultis & Myneni (1987)
    a = cos(Œ∏) * cos(Œ∏‚Çó)
    # Eq. 14.24 in Bonan et al.
    if Œ∏‚Çó ‚â§ (FT(œÄ/2) - Œ∏)
        return a
    else
        b = sin(Œ∏) * sin(Œ∏‚Çó)
        c = sqrt(FT(1)-(a/b)^2)
        return FT(2/œÄ)*(a * (acos(-a/b)-œÄ/2) + b * c) # (1/œÄ) * (cosŒ∏.cosŒ∏‚Çó.cos‚Åª¬π(cotŒ∏.cotŒ∏‚Çó) + sinŒ∏.sinŒ∏‚Çó.‚àö(1-cot¬≤Œ∏.cot¬≤Œ∏‚Çó))
    end
end



"""
    $(FUNCTIONNAME)(Œº::Array{FT}, LD::AbstractLeafDistribution; nLeg=20)

Returns the integrated projection of leaf area in the direction of Œº, assumes azimuthally uniform distribution and a LD distribution for leaf polar angle Œ∏. 
This function is often referred to as the function O(B) (Goudriaan 1977) or G(Œñ) (Ross 1975,1981), see Bonan modeling book, eqs. 14.21-14.26. 

# Arguments
- `Œº` an array of cos(Œ∏) (directions [0,1]) 
- `LD` an [`AbstractLeafDistribution`](@ref) type struct, includes a leaf distribution function
- `nLeg` an optional parameter for the number of legendre polynomials to integrate over the leaf distribution (default=20)

# Examples
```julia-repl
julia> Œº,w = CanopyOptics.gauleg(10,0.0,1.0);       # Create 10 quadrature points in Œº      
julia> LD  = CanopyOptics.spherical_leaves()        # Create a default spherical leaf distribution
julia> G   = CanopyOptics.G(Œº, LD)                  # Compute G(Œº)
10-element Vector{Float64}:
 0.5002522783000879
 0.5002715115149204
 0.5003537989277846
 0.5004432798701134
 0.5005134448870893
 0.5003026448466977
 0.4999186257540982
 0.4994511190721635
 0.49907252201082375
 0.49936166823681594
```
"""
function G(Œº::AbstractArray{FT}, LD::AbstractLeafDistribution; nLeg=40) where FT
    Œ∏‚Çó,w = gauleg(nLeg,FT(0),FT(œÄ/2))
    b = range(FT(0),FT(œÄ/2), length=nLeg)
    Œ∏‚Çó = (b[1:end-1] + b[2:end])/2
    #@show length(Œ∏‚Çó )
    w = œÄ / 2 / (nLeg-1)
    F·µ¢ = pdf.(LD.LD,2Œ∏‚Çó/œÄ) * LD.scaling #.* sin.(Œ∏‚Çó) * œÄ/2
    #F·µ¢ = 2/œÄ * (1.0 .+ cos.(2Œ∏‚Çó)) 
    # renormalize (needed if quadrature doesn't work)
    #@show sum(w' * F·µ¢)
    F·µ¢ = F·µ¢ / sum(w * F·µ¢)
    Œ∏ = acos.(Œº)
    #@show size(A.(Œ∏',Œ∏‚Çó))
    #@show size(w * F·µ¢)
    G = (w * F·µ¢)' * A.(Œ∏',Œ∏‚Çó)
    return G'
end

function G2(Œº::AbstractArray{FT}, LD::AbstractLeafDistribution; nLeg=40) where FT
    Œºl,w = gauleg(nLeg,FT(0),FT(1))
    Œ∏‚Çó = acos.(Œºl)
    F·µ¢ = pdf.(LD.LD,2Œ∏‚Çó/œÄ) * LD.scaling * œÄ/2 
    F·µ¢ = F·µ¢ ./ (w'*F·µ¢)
    Œ∏ = acos.(Œº)
    G = (w .* F·µ¢)' * A.(Œ∏',Œ∏‚Çó)
    return G'
end

"Brute Force G calculation (for testing"
function bfG(Œº::Array{FT}, LD::AbstractLeafDistribution; nLeg=20) where FT
    nQuad = 100
    œï, w_azi = gauleg(nQuad,FT(0),FT(2œÄ));
    # Reference angles to integrate over in both œï and Œº
    
    Œº_l, w = gauleg(180,0.0,1.0);
    Œ©_l  = [dirVector_Œº(a,b) for a in Œº_l, b in œï];
    Œ∏‚Çó = acos.(Œº_l)
    # Have to divide by sin(Œ∏) again to get ‚àÇŒ∏/‚àÇŒº for integration (weights won't work)
    F·µ¢ = pdf.(LD.LD,2Œ∏‚Çó/œÄ)  * LD.scaling * œÄ/2#./ abs.(sin.(Œ∏‚Çó))
    @show F·µ¢' * w 
    F·µ¢ = F·µ¢ ./ (F·µ¢' * w)
    #@show F·µ¢' * w
    res = similar(Œº);
    
    for i in eachindex(Œº)
        Œ© = dirVector_Œº(Œº[i],0.0);
        #res[i] =  sum(w .* F·µ¢ .* A.(Œ∏[i],Œ∏‚Çó))
        # Double integration here:
        res[i] =  ((F·µ¢ .* abs.(dot.((Œ©,),Œ©_l)))' * w)' * w_azi /(2œÄ)
    end
    return res
end



"""
    $(FUNCTIONNAME)(Œº::Array{FT,1},ŒºÍúõ::Array{FT,1}, r,t, LD::AbstractLeafDistribution; nLeg = 20)

Computes the azimuthally-averaged area scattering transfer function following Shultis and Myneni (https://doi.org/10.1016/0022-4073(88)90079-9), Eq 43:

``Œì(Œº' -> Œº) = \\int_0^1 dŒº_L g_L(Œº_L)[t_L Œ®‚Å∫(Œº, Œº', Œº_L) + r_L Œ®‚Åª(Œº, Œº', Œº_L)]``

assuming an azimuthally uniform leaf angle distribution.
# Arguments
- `Œº::Array{FT,1}` : Quadrature points incoming direction (cos(Œ∏))
- `ŒºÍúõ::Array{FT,1}`: Quadrature points outgoing direction (cos(Œ∏))
- `r` : Leaf lambertian reflectance
- `t` : Leaf lambertian transmittance
- `LD` a [`AbstractLeafDistribution`](@ref) struct that describes the leaf angular distribution function.
- `nLeg = 20`: number of quadrature points used for integration over all leaf angles (default is 20).
"""
function compute_lambertian_Œì(Œº::Array{FT,1},ŒºÍúõ::Array{FT,1}, r,t, LD::AbstractLeafDistribution; nLeg = 20) where FT
    Œì = zeros(length(Œº), length(Œº))
    Œ∏‚Çó,w = gauleg(nLeg,FT(0),FT(œÄ/2))
    for i in eachindex(Œ∏‚Çó)
        Œ®‚Å∫, Œ®‚Åª = compute_Œ®(Œº,ŒºÍúõ, cos(Œ∏‚Çó[i]));
        Œì += pdf.(LD.LD,2Œ∏‚Çó[i]/œÄ) * LD.scaling * w[i] * (t * Œ®‚Å∫ + r * Œ®‚Åª)
    end
    return Œì
end

"""
    $(FUNCTIONNAME)(mod::BiLambertianCanopyScattering, Œº::Array{FT,1}, LD::AbstractLeafDistribution, m::Int)

Computes the single scattering Z matrices (ùêô‚Å∫‚Å∫ for same incoming and outgoing sign of Œº, ùêô‚Åª‚Å∫ for a change in direction). Internally computes the azimuthally-averaged area scattering transfer function following Shultis and Myneni (https://doi.org/10.1016/0022-4073(88)90079-9), Eq 43::

``Œì(Œº' -> Œº) = \\int_0^1 dŒº_L g_L(Œº_L)[t_L Œ®‚Å∫(Œº, Œº', Œº_L) + r_L Œ®‚Åª(Œº, Œº', Œº_L)]``

assuming an azimuthally uniform leaf angle distribution. Normalized Œì as ùêô = 4Œì/(œñ‚ãÖG(Œº)).
Returns ùêô‚Å∫‚Å∫, ùêô‚Åª‚Å∫ 

# Arguments
- `mod` : A bilambertian canopy scattering model [`BiLambertianCanopyScattering`](@ref), uses R,T,nQuad from that model.
- `Œº::Array{FT,1}`: Quadrature points ‚àà [0,1]
- `LD` a [`AbstractLeafDistribution`](@ref) struct that describes the leaf angular distribution function.
- `m`: Fourier moment (for azimuthally uniform leave distributions such as here, only m=0 returns non-zero matrices)
"""
function compute_Z_matrices(mod::BiLambertianCanopyScattering, Œº::Array{FT,1}, LD::AbstractLeafDistribution, m::Int) where FT
    (;R,T,nQuad) = mod
    # Transmission (same direction)
    ùêô‚Å∫‚Å∫ = zeros(length(Œº), length(Œº))
    # Reflection (change direction)
    ùêô‚Åª‚Å∫ = zeros(length(Œº), length(Œº))
    
    # skip everything beyond m=0
    if m>0  
        return ùêô‚Å∫‚Å∫, ùêô‚Åª‚Å∫
    end
    # Ross kernel
    G = CanopyOptics.G(Œº, LD)
    # Single Scattering Albedo (should make this a vector too)
    œñ = R+T

    Œ∏‚Çó,w = gauleg(nQuad,FT(0),FT(œÄ/2));
    for i in eachindex(Œ∏‚Çó)
        Œ®‚Å∫, Œ®‚Åª = compute_Œ®(Œº,Œº, cos(Œ∏‚Çó[i]));
        ùêô‚Å∫‚Å∫ += pdf.(LD.LD,2Œ∏‚Çó[i]/œÄ) * LD.scaling * w[i] * (T * Œ®‚Å∫ + R * Œ®‚Åª) 
        Œ®‚Å∫, Œ®‚Åª = compute_Œ®(Œº,-Œº, cos(Œ∏‚Çó[i]));
        ùêô‚Åª‚Å∫ += pdf.(LD.LD,2Œ∏‚Çó[i]/œÄ) * LD.scaling * w[i] * (T * Œ®‚Å∫ + R * Œ®‚Åª) 
    end
    return 4ùêô‚Å∫‚Å∫ ./(G'*œñ), 4ùêô‚Åª‚Å∫ ./(G'*œñ)
end

# Page 20, top of Knyazikhin and Marshak
# Example 
# œï = range(0.0, 2œÄ,  length=200)
# Œ∏ = range(0.0, œÄ/2, length=150)
# dirs = [dirVector(a,b) for a in Œ∏, b in œï];
# R = CanopyOptics.compute_specular_reflection.([dirs[10,1]],dirs, [1.5], [0.3], [LD])
function compute_reflection(mod::SpecularCanopyScattering, Œ©‚Å±‚Åø::dirVector{FT}, Œ©·µí·µò·µó::dirVector{FT}, LD) where FT
    (;n·µ£,Œ∫) = mod
    Œ©star = getSpecularŒ©(Œ©‚Å±‚Åø, Œ©·µí·µò·µó)
    #Œ∏star = min(abs(Œ©star.Œ∏), (œÄ-abs(Œ©star.Œ∏))) # min(abs(Œ©star.Œ∏), abs(œÄ+Œ©star.Œ∏))
    Œ∏star = Œ©star.Œ∏;
    #if Œ©‚Å±‚Åø.Œ∏ ‚âà Œ©·µí·µò·µó.Œ∏ && Œ©‚Å±‚Åø.œï ‚âà Œ©·µí·µò·µó.œï
    #    Œ∏star = Œ©‚Å±‚Åø.Œ∏
    #end
    # Still needs to be implemented!
    # incident angle on leaf surface (half of in and out angle):
    sa = Œ©‚Å±‚Åø ‚ãÖ Œ©·µí·µò·µó 
    sa > 1 ? sa = FT(1) : nothing
    Œ±star = acos(abs(sa))/2
    #@show Œ©star.œï, Œ©star.Œ∏
    #a = (Œ©‚Å±‚Åø ‚ãÖ Œ©star) * (Œ©·µí·µò·µó ‚ãÖ Œ©star)
    return FT(1/8) * pdf(LD.LD,2Œ∏star/œÄ) * LD.scaling * K(Œ∫, Œ±star) * F·µ£(n·µ£,Œ±star)
    
end

function compute_Œì(mod::BiLambertianCanopyScattering, Œ©‚Å±‚Åø::dirVector_Œº{FT}, Œ©·µí·µò·µó::dirVector_Œº{FT}, LD::AbstractLeafDistribution) where FT
    (;R,T, nQuad) = mod
    #nQuad = 80
    #Œº_l, w = gauleg(nQuad,0.0,1.0);
    Œ∏‚Çó, w = gauleg(nQuad,FT(0),FT(œÄ/2));
    Œº_l = cos.(Œ∏‚Çó)
    # Quadrature points in the azimuth (this has to go over 2œÄ):
    œï, w_azi = gauleg(nQuad+1,FT(0),FT(2œÄ));
    
    F·µ¢ = pdf.(LD.LD,2Œ∏‚Çó/œÄ) * LD.scaling  
    
    # Create leaf angles in Œº and œï
    Œ©_l  = [dirVector_Œº(a,b) for a in Œº_l, b in œï];
    
    # Compute the angles (in, leaf angles, out, leaf)
    integrand = ((Œ©‚Å±‚Åø,) .‚ãÖ Œ©_l) .* ((Œ©·µí·µò·µó,) .‚ãÖ Œ©_l)

    # Integrate over positive and negatives separately
    iPos = (integrand+abs.(integrand))./2
    iNeg = (integrand-abs.(integrand))./2
    
    # Eq 39 in Shultis and Myneni, double integration here
    Œì‚Åª = -1/2œÄ * (F·µ¢ .* w)' * (iNeg * w_azi) 
    Œì‚Å∫ =  1/2œÄ * (F·µ¢ .* w)' * (iPos * w_azi) 
    @show 
    # Eq 38 in Shultis and Myneni
    return R * Œì‚Åª + T * Œì‚Å∫ 
end

function compute_reflection(mod::SpecularCanopyScattering,Œ©‚Å±‚Åø::dirVector_Œº{FT}, Œ©·µí·µò·µó::dirVector_Œº{FT}, LD::AbstractLeafDistribution) where FT
    (;n·µ£,Œ∫) = mod
    Œ©star, Œ±star = getSpecularŒ©(Œ©‚Å±‚Åø, Œ©·µí·µò·µó)
    # Can change this later as well do have the pdf in Œº, not theta!
    Œ∏star = acos(abs(Œ©star.Œº));
    # Eq. 2.39 in "Discrete Ordinates Method for Photon Transport in Leaf Canopies", page 59
    return FT(1/8) * pdf(LD.LD,2Œ∏star/œÄ) * LD.scaling * K(Œ∫, Œ±star) * F·µ£(n·µ£,Œ±star)
end

function compute_Z_matrices(mod::SpecularCanopyScattering, Œº::Array{FT,1}, LD::AbstractLeafDistribution, m::Int) where FT
    (;n·µ£, Œ∫, nQuad) = mod
    # Transmission (same direction)
    ùêô‚Å∫‚Å∫ = zeros(length(Œº), length(Œº))
    # Reflection (change direction)
    ùêô‚Åª‚Å∫ = zeros(length(Œº), length(Œº))
    
    # Quadrature points in the azimuth:
    œï, w_azi = gauleg(nQuad,FT(0),FT(2œÄ));
    # Fourier weights (cosine decomposition)
    f_weights = cos.(m*œï)
    
    for i in eachindex(Œº)
        # Incoming beam at œï = 0
        Œ©‚Å±‚Åø = dirVector_Œº(Œº[i], FT(0));
        # Create outgoing vectors in Œ∏ and œï
        dirOutÍúõ = [dirVector_Œº(a,b) for a in Œº, b in œï];
        dirOutÍúú = [dirVector_Œº(a,b) for a in -Œº, b in œï];
        # Compute over Œº and Œº_azi:
        Zup   = compute_reflection.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúõ, (LD,));
        Zdown = compute_reflection.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúú, (LD,));
        # integrate over the azimuth:
        ùêô‚Åª‚Å∫[i,:] = Zup   * (w_azi .* f_weights)
        ùêô‚Å∫‚Å∫[i,:] = Zdown * (w_azi .* f_weights)
    end
    return ùêô‚Å∫‚Å∫, ùêô‚Åª‚Å∫
end

function compute_Z_matrices_aniso(mod::BiLambertianCanopyScattering, Œº::AbstractArray{FT,1}, LD::AbstractLeafDistribution, m::Int) where FT
    (;R,T, nQuad) = mod
    # Ross kernel
    G = CanopyOptics.G(Array(Œº), LD)
    @show G
    # Single Scattering Albedo (should make this a vector too)
    œñ = R+T

    # Transmission (same direction)
    ùêô‚Å∫‚Å∫ = zeros(length(Œº), length(Œº))
    # Reflection (change direction)
    ùêô‚Åª‚Å∫ = zeros(length(Œº), length(Œº))
    
    # Quadrature points in the azimuth:
    # Y. Knyazikhin and A. Marshak, eq. A.9a
    œï, w_azi = gauleg(nQuad,FT(0),FT(œÄ));
    w_azi *= 2/FT(œÄ)
    ff = m==0 ? FT(2) : FT(4)
    #if m>0
    #     w_azi /= 2
    #end
    # Fourier weights (cosine decomposition)
    f_weights = cos.(m*œï)
    
    # Create outgoing vectors in Œ∏ and œï
    dirOutÍúõ = [dirVector_Œº(a,b) for a in -Œº, b in œï];
    dirOutÍúú = [dirVector_Œº(a,b) for a in  Œº, b in œï];

    for i in eachindex(Œº)
        # Incoming beam at œï = 0
        Œ©‚Å±‚Åø = dirVector_Œº(Œº[i], FT(0));
        # Compute over Œº and Œº_azi:
        Zup   = compute_Œì.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúõ, (LD,));
        Zdown = compute_Œì.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúú, (LD,));
        #Zup   = compute_Œì_isotropic.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúõ);
        #Zdown = compute_Œì_isotropic.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúú);
        # integrate over the azimuth:
        ùêô‚Åª‚Å∫[:,i] = ff * Zup   / œñ   * (w_azi .* f_weights)
        ùêô‚Å∫‚Å∫[:,i] = ff * Zdown / œñ   * (w_azi .* f_weights)
    end
    return ùêô‚Å∫‚Å∫, ùêô‚Åª‚Å∫
end

function compute_Œì_isotropic(mod::BiLambertianCanopyScattering, Œ©‚Å±‚Åø::dirVector_Œº{FT}, Œ©·µí·µò·µó::dirVector_Œº{FT}) where FT
    (;R,T, nQuad) = mod
    Œ≤ = acos( Œ©·µí·µò·µó ‚ãÖ Œ©‚Å±‚Åø)
    œâ = R + T
    
    # Eq 40 in Shultis and Myneni
    Œì = (œâ/3œÄ) * (sin(Œ≤) - Œ≤ * cos(Œ≤)) + T/3*cos(Œ≤)
    return Œì
end

function compute_Z_matrices_aniso(mod::BiLambertianCanopyScattering,Œº::AbstractArray{FT,1},LD::AbstractLeafDistribution, Zup, Zdown, m::Int) where FT
    (;R,T, nQuad) = mod
    # Ross kernel
    
    # Single Scattering Albedo (should make this a vector too)
    œñ = R+T

    # Transmission (same direction)
    ùêô‚Å∫‚Å∫ = similar(Œº,(length(Œº), length(Œº)))
    # Reflection (change direction)
    ùêô‚Åª‚Å∫ = similar(Œº,(length(Œº), length(Œº)))

    # Quadrature points in the azimuth:
    œï, w_azi = gauleg(nQuad,FT(0),FT(œÄ));
    w_azi *= 2/FT(œÄ)
    w_azi = typeof(Œº)(w_azi)
    ff = m==0 ? FT(2) : FT(4)
    
    # Fourier weights (cosine decomposition)
    f_weights = typeof(Œº)(cos.(m*œï))

    for i in eachindex(Œº)
        # integrate over the azimuth:
        @views ùêô‚Åª‚Å∫[i,:] = ff * Zup[i,:,:]   /œñ   * (w_azi .* f_weights)
        @views ùêô‚Å∫‚Å∫[i,:] = ff * Zdown[i,:,:] /œñ   * (w_azi .* f_weights)

    end
    return ùêô‚Å∫‚Å∫, ùêô‚Åª‚Å∫
end


function precompute_Zazi(mod::BiLambertianCanopyScattering, Œº::AbstractArray{FT,1}, LD::AbstractLeafDistribution) where FT
    (;R,T, nQuad) = mod
    nQuad = nQuad
    # Quadrature points in the azimuth:
    œï, w_azi = gauleg(nQuad,FT(0),FT(œÄ));
    # Fourier weights (cosine decomposition)
    
    # Transmission (same direction)
    Zup = zeros(length(Œº),length(Œº), nQuad)
    # Reflection (change direction)
    Zdown = zeros(length(Œº),length(Œº), nQuad)
    
    # Create outgoing vectors in Œ∏ and œï
    dirOutÍúõ = [dirVector_Œº(a,b) for a in -Œº, b in œï];
    dirOutÍúú = [dirVector_Œº(a,b) for a in Œº, b in œï];

    Threads.@threads for i in eachindex(Œº)
        # Incoming beam at œï = 0
        Œ©‚Å±‚Åø = dirVector_Œº(Œº[i], FT(0));
        # Compute over Œº and Œº_azi:
        Zup[i,:,:]   = compute_Œì.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúõ, (LD,));
        Zdown[i,:,:] = compute_Œì.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúú, (LD,));
        #Zup[:,:,i]   = compute_Œì_isotropic.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúõ);
        #Zdown[:,:,i] = compute_Œì_isotropic.((mod,),(Œ©‚Å±‚Åø,),dirOutÍúú);
    end
    return Zup, Zdown
end

function precompute_Zazi_(mod::BiLambertianCanopyScattering, Œº::AbstractArray{FT,1}, LD::AbstractLeafDistribution) where FT
    (;R,T, nQuad) = mod
    # Quadrature points in Œº
    n_Œº  = length(Œº);
    arr_type = typeof(Œº);

    #Œº,w         = CanopyOptics.gauleg(n_Œº,   FT(0),  FT(1.0));
    dœï,  w_azi  = CanopyOptics.gauleg(nQuad, FT(0),  FT(œÄ));
    dœï·¥∏, w_azi·¥∏ = CanopyOptics.gauleg(nQuad+1, FT(0),  FT(2œÄ));
    Œ∏·¥∏,w·¥∏       = CanopyOptics.gauleg(nQuad, FT(0),FT(œÄ/2));
    
    Œº·¥∏ = cos.(Œ∏·¥∏)
    F·µ¢ = pdf.(LD.LD,2Œ∏·¥∏/œÄ) * LD.scaling
    @show sum(w·¥∏ .* F·µ¢)
    # Reshape stuff:
    Œº‚Å±‚Åø   = reshape(arr_type(Œº),  n_Œº,  1,     1,     1,     1   );
    Œº·µí·µò·µó  = reshape(arr_type(deepcopy(Œº)), 1,   n_Œº,    1,     1,     1   );
    _dœï   = reshape(arr_type(dœï), 1,    1,   nQuad,   1,     1   );
    _Œº·¥∏   = reshape(arr_type(Œº·¥∏), 1,    1,     1,   nQuad,   1   );
    _dœï·¥∏  = reshape(arr_type(dœï·¥∏),1,    1,     1,     1,   nQuad+1 );

    # Quadrature points:
    w·¥∏  = w·¥∏ .*  F·µ¢
    #_w_azi  = reshape(arr_type(w_azi),  1,  1,   nQuad,   1,     1   );
    _w·¥∏     = reshape(arr_type(w·¥∏),     1,  1,    1,    nQuad,   1   );
    _w_azi·¥∏ = reshape(arr_type(w_azi·¥∏), 1,  1,    1,      1,    nQuad+1);

    integrand  =  CanopyOptics.leaf_dot_products.(Œº‚Å±‚Åø, -Œº·µí·µò·µó, _dœï,_Œº·¥∏, _dœï·¥∏);
    iPos       = (integrand+abs.(integrand))./2;
    iNeg       = (integrand-abs.(integrand))./2;
    Œì‚Åª         = -1/2œÄ * sum(sum(iNeg.*_w_azi·¥∏, dims=5).*_w·¥∏,dims=4); 
    Œì‚Å∫         =  1/2œÄ * sum(sum(iPos.*_w_azi·¥∏, dims=5).*_w·¥∏,dims=4);

    Œì = R .* Œì‚Åª .+ T .* Œì‚Å∫; 
    Œìup = reshape(Œì, n_Œº,n_Œº, nQuad);
    
    integrand  =  CanopyOptics.leaf_dot_products.(Œº‚Å±‚Åø, Œº·µí·µò·µó, _dœï,_Œº·¥∏, _dœï·¥∏);
    iPos       = (integrand+abs.(integrand))./2;
    iNeg       = (integrand-abs.(integrand))./2;
    Œì‚Åª         = -1/2œÄ * sum(sum(iNeg.*_w_azi·¥∏, dims=5).*_w·¥∏,dims=4); 
    Œì‚Å∫         =  1/2œÄ * sum(sum(iPos.*_w_azi·¥∏, dims=5).*_w·¥∏,dims=4);
    
    Œì = R .* Œì‚Åª .+ T .* Œì‚Å∫; 
    Œìdown = reshape(Œì, n_Œº,n_Œº, nQuad);
    return Œìup,Œìdown
end


"The reduction factor proposed by Nilson and Kuusk, Œ∫ ‚âà 0.1-0.3, returns exp(-Œ∫ * tan(abs(Œ±))"
function K(Œ∫::FT, Œ±::FT) where FT 
    exp(-Œ∫ * tan(abs(Œ±)));
end

function leaf_dot_products(Œº‚Å±‚Åø::FT, Œº·µí·µò·µó::FT, dœï·µí·µò·µó::FT, Œº·¥∏::FT, dœï·¥∏::FT) where FT
    (Œº‚Å±‚Åø  * Œº·¥∏ + sqrt(1-Œº‚Å±‚Åø^2)   * sqrt(1-Œº·¥∏^2) * cos(dœï·¥∏)) *
    (Œº·µí·µò·µó * Œº·¥∏ + sqrt(1-Œº·µí·µò·µó^2)  * sqrt(1-Œº·¥∏^2) * cos(dœï·¥∏ - dœï·µí·µò·µó))
end
